#### 锁

- 处理并发读写访问的系统通常实现一个由两种锁类型组成的锁系统，这两种类型分别是：
    - 共享锁（share lock），也叫读锁（read lock）
    - 排他锁（exclusive lock）,也叫写锁（write lock）

#### 锁的粒度，两种重要的锁策略

- 两种重要的锁策略：
- 表锁（table
  lock），是mysql中最基本也是开销最小的锁策略。他会锁定整张表。他会锁定整张表。当客户端想对表进行写操作（插入、写入、更新等）时，  
  要先获得一个写锁，这会阻塞其他客户端对该表的所有读写操作。只有没有人执行写操作时，其他客户端才能获得读锁，读锁之间不会阻塞。
- 行锁（row
  lock），使用行级锁可以最大程度地支持并发处理（也带来了最大的锁开销）。这种策略允许多人同时编辑不同的行，而不会阻塞彼此。这使得服务器可以执行更多的并发写操作，带来的代价则是需要承担更多的开销，以跟踪谁拥有这些行级锁、已经锁定了多长时间、行即所得类型，以及何时清理不在需要的行级锁
  行级锁是在存储引擎中实现的。

#### 死锁

- 死锁是指两个或多个事务互相持有和请求相同资源上的锁，产生了循环依赖。
- 死锁的原因：
    - 当多个事务视图以不同顺序锁定资源时会产生死锁
    - 当多个事务锁定相同资源时也可能会产生死锁

#### 死锁的解决方法：

- ![死锁的处理.jpeg](..%2Fstatic%2F%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86.jpeg)

#### 事务日志
- 

#### 事务的隔离级别

- READ UNCOMMITTED（未提交读）
    - 在事务中可以查看到其他事务还没有提交的修改，在实际中一般很少用
- READ COMMITTED（提交读）
    - 大多数数据库系统默认的隔离级别时READ
      COMMITTED（但mysql不是），一个事务可以看到其他事务在他开始之后提交的修改，但在该事务提交之前，其所做的任何修改对其他事务都是不可见的，这意味着同一事务中两次执行相同语句，可能看到不同的结果。
- REPEATABLE READ（可重复度）
    - 解决了READ COMMITTED界别的不可重复读问题，保证了在同一事务中，多次读取相同行数据的结果是一样的。但是理论上该级别无法解决幻读的问题，
    - mysql默认在该隔离级别。


